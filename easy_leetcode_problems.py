'''
Problem ----------------------------------------------------------------------------------------------------------

Given the array nums, for each nums[i] find out how many numbers in the array 
are smaller than it. That is, for each nums[i] you have to count the number 
of valid j's such that j != i and nums[j] < nums[i]. Return the answer in an array.

Runtime: 40 ms, faster than 88.13% of Python online submissions for How Many Numbers 
Are Smaller Than the Current Number.

'''


def smallerNumbersThanCurrent(nums):

    sorted_nums = list(sorted(nums))
    return [sorted_nums.index(num) for num in nums]

# ------------------------------------------------------------------------------------------------------------------


'''
Problem ----------------------------------------------------------------------------------------------------------

You're given strings J representing the types of stones that are jewels, 
and S representing the stones you have.  Each character in S is a type of stone you have.  
You want to know how many of the stones you have are also jewels.
The letters in J are guaranteed distinct, and all characters in J and S are letters. 
Letters are case sensitive, so "a" is considered a different type of stone from "A".


Runtime: 12 ms, faster than 95.33% of Python online submissions for Jewels and Stones.
'''


def numJewelsInStones(J, S):
    return sum([S.count(char) for char in J])


# ------------------------------------------------------------------------------------------------------------------
'''

Problem ----------------------------------------------------------------------------------------------------------


Given a positive integer num consisting only of digits 6 and 9.
Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).

Input: num = 9669
Output: 9969

Input: num = 9996
Output: 9999

Runtime: 16 ms, faster than 73.48% of Python online submissions for Maximum 69 Number.
'''


def maximum69Number(num):
    num_str = str(num)
    if '6' in num_str:
        index = num_str.index('6')
        result_str = num_str[:index] + '9' + num_str[index+1:]
        return int(result_str)
    else:
        return num

# ------------------------------------------------------------------------------------------------------------------


'''
Problem ----------------------------------------------------------------------------------------------------------
Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t.

Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.

Runtime: 20 ms, faster than 85.08% of Python online submissions for Find the Difference.
'''


def findTheDifference(s, t):
    sorted_s = sorted(s)
    sorted_t = sorted(t)
    for i in range(len(sorted_s)):
        if sorted_s[i] != sorted_t[i]:
            return sorted_t[i]
    return sorted_t[-1]


'''

Problem ----------------------------------------------------------------------------------------------------------

Given an array of integers arr, replace each element with its rank.

The rank represents how large the element is. The rank has the following rules:

Rank is an integer starting from 1.
The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
Rank should be as small as possible.

Runtime: 336 ms, faster than 87.61% of Python online submissions for Rank Transform of an Array.
'''


def arrayRankTransform(self, arr):
    new_arr = sorted(set(arr))
    rank_arr = list(range(1, len(new_arr) + 1))
    new_dict = dict(zip(new_arr, rank_arr))
    return [new_dict[x] for x in arr]

# ------------------------------------------------------------------------------------------------------------------


'''

Problem ----------------------------------------------------------------------------------------------------------

Given a string containing just the characters 
'(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Runtime: 64 ms, faster than 82.51% of Python online submissions for 
Remove All Adjacent Duplicates In String.
'''


class Stack:

    def __init__(self):
        self._data = []

    def push(self, element):
        self._data.append(element)

    def pop(self):
        if self.is_empty():
            raise Empty('Stack is empty')
        return self._data.pop()

    def top(self):
        if self.is_empty():
            raise Empty('Stack is empty')
        return self._data[-1]

    def is_empty(self):
        return len(self._data) == 0


'''

Problem ----------------------------------------------------------------------------------------------------------


faster than 82.51% of Python online submissions for 
Remove All Adjacent Duplicates In String


Given a string S of lowercase letters, 
a duplicate removal consists of choosing two adjacent and equal letters, 
and removing them.

We repeatedly make duplicate removals on S until we no longer can.

Return the final string after all such duplicate removals have been made.  
It is guaranteed the answer is unique.
'''


class Solution(object):
    def get_reversed(self, bracket):

        reverse_dict = {'(': ')', '{': '}',
                        '[': ']', ')': '(', '}': '{', ']': '['}
        return reverse_dict[bracket]

    def isValid(self, s):
        stack = Stack()
        for char in s:
            if stack.is_empty():
                stack.push(char)
            else:
                if stack.top() == self.get_reversed(char):
                    stack.pop()
                else:
                    stack.push(char)
        return stack.is_empty()

# ------------------------------------------------------------------------------------------------------------------


def removeDuplicates(S):
    my_list = []
    for char in S:
        if not my_list:
            my_list.append(char)
        else:
            if char == my_list[-1]:
                my_list.pop()
            else:
                my_list.append(char)
    return ''.join(my_list)

# ------------------------------------------------------------------------------------------------------------------


'''
Problem ----------------------------------------------------------------------------------------------------------


    Merge two sorted linked lists and return it as a new list.
    The new list should be made by splicing together the nodes of 
    the first two lists.
'''


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __str__(self):
        if self.next == None:
            return f'{self.val}'
        else:
            return f'{self.val}' + ' -- ' + self.next.__str__()


class Solution:

    def mergeTwoLists(self, l1, l2):

        if not l1 or not l2:
            return l1 or l2

        l3 = ListNode(l1.val)
        cur = l3

        while l1 or l2:
            if not l1:
                cur.next = ListNode(l2.val)
                cur = cur.next
                l2 = l2.next
            elif not l2:
                cur.next = ListNode(l1.val)
                cur = cur.next
                l1 = l1.next
            elif l1.val < l2.val:
                cur.next = ListNode(l1.val)
                cur = cur.next
                l1 = l1.next
            else:
                cur.next = ListNode(l2.val)
                cur = cur.next
                l2 = l2.next
        l3 = l3.next
        return l3

# ------------------------------------------------------------------------------------------------------------------


class Solution:
    def deleteDuplicates(self, head):
        current = head
        while current.next != None:
            if current.next.val == current.val:
                current = current.next.next
            else:
                current = current.next
        return head


l1 = ListNode(1)
l1.next = ListNode(2)
l1.next.next = ListNode(2)
l1.next.next.next = ListNode(2)

soln = Solution()
l2 = soln.deleteDuplicates(l1)

'''

Problem ----------------------------------------------------------------------------------------------------------


    Remove all elements from a linked list of integers that have value val.

    Runtime: 56 ms, faster than 92.34% of 
    Python online submissions for Remove Linked List Elements.


'''


class Solution(object):
    def removeElements(self, head, val):

        if not head:
            return None

        curr = head

        while curr.next:
            if head.val == val:
                head = head.next
                curr = head
            elif curr.next.val != val:
                curr = curr.next
            else:
                temp = curr
                while temp.next and temp.next.val == val:
                    temp = temp.next
                curr.next = temp.next
        if head.val == val:
            return None
        return head

# ------------------------------------------------------------------------------------------------------------------


'''

Problem ----------------------------------------------------------------------------------------------------------

We are given a list nums of integers representing a list compressed with run-length encoding.
Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  
For each such pair, there are freq elements with value val concatenated in a sublist. 
Concatenate all the sublists from left to right to generate the decompressed list.
Return the decompressed list.

Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].

Runtime: 44 ms, faster than 99.14% of Python online submissions for Decompress Run-Length Encoded List.
Memory Usage: 13 MB, less than 100.00% of Python online submissions for Decompress Run-Length Encoded List.

'''
